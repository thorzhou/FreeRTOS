栈？任务栈？

在裸机系统中（主栈），局部变量都放在栈中，栈是RAM里一段连续的内存空间，栈的大小在启动文件或者链接脚本里指定，最后由C库函数_main进行初始化。

多任务系统中（主栈、堆），每个任务都是独立的，互不干扰的，所以要为每个任务都分配独立的栈空间，这个栈空间通常是一个预先定义好的全局数组，也可以是动态分配的一段内存空间（堆），但他们都存在于RAM中。

任务是一个独立的函数，函数主体无限循环且不能返回。

定义任务栈是一段连续的内存，类似数组，类型是StackType_t，长度TASK_STACK_LEN

任务控制块TCB
    - 定义是用做CPU调度任务
    - 相当于任务的身份证，里面存有任务的所有信息，比如任务的栈指针，任务名称，任务的形参等。
    - 定义一个TCB需要一个新的数据类型，该数据类型在task.c声明，（为使用tskTCB声明在FreeRTOS.h中）

任务的栈，任务的函数实体，任务的控制块最终需要联系起来才能由系统进行统一调度。那么这个联系的工作就由任务创建函数xTaskCreatStatic()来实现，task.c

Freertos中，任务创建有两种，动态创建，静态创建。
    - 动态创建，TCB和栈内存是创建任务时动态分配的，任务删除时，内存释放。
    - 静态创建，TCB和栈内存需要事先定义好，是静态内存，任务删除时，内存不能释放。

任务创建好之后，把任务添加到就绪列表里面，表示人物已经就绪，系统随时可以调度。
就绪列表实际就是一个List_t的数组，数组大小由决定最大任务优先级的宏configMAX_PRIORITIES
初始化就绪列表，就是每个数组元素初始化一遍任务列表
将任务插入就绪列表
实际顺序：初始化列表，创建任务，将任务插入到就绪列表
完成后由调度器实现任务的切换。
调度器实际就是由几个全局变量和一些可实现任务切换的函数组成，全都在task.c中。
调度器由PendSV和SysTick中断实现，所以要把这两个中断优先级设置为最低。

Coretex-M内核三个中断屏蔽寄存器
PRIMASK     - 这是个只有单一bit的寄存器。在置1后，就关掉所有可屏蔽的异常，只剩下NMI和硬FAULT可以响应。它的缺省值是0，表示没有关中断。
FAULTMASK   - 这是个只有一个位的寄存器。在置1后，只有NMI才能响应，其他所有通通屏蔽。它的缺省值也是0，表示没有关中断。
BASEPRI     - 这个寄存器最多有9位（由表达优先级的位数决定）。它定义了被屏蔽优先级的阈值。
              当它被设成某个值后，所有优先级号大于等于此值的中断都被关（优先级号越大，优先级越低）。
              但若被设为0，则不关闭任何中断，0也是缺省值。

SVC中断要想被成功响应，其函数名必须与向量表注册的名称一致，在启动文件的向量表中，SVC的中断服务函数注册的名称是SVC_Handler，所以SVC中断服务函数的名称应该谢伟SVC_Handler，但是freertos中官方版本写的是vPortSVCHandler()

任务切换就是在就绪列表中寻找优先级最高的就绪任务，然后去执行该任务。taskYIELD()